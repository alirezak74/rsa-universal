'use client';

import React, { useEffect, useState } from 'react';
import Layout from '@/components/Layout';
import { apiClient } from '@/lib/api';
import toast from 'react-hot-toast';
import { Edit3, Trash2, RefreshCw, Plus, Search, Filter, RotateCcw, X, Globe, Link, Zap, CheckCircle, AlertCircle, Clock } from 'lucide-react';

interface ChainContract {
  contract: string;
  decimals?: number;
  verified?: boolean;
}

interface NetworkSupport {
  ethereum: boolean;
  bsc: boolean;
  solana: boolean;
  avalanche: boolean;
  polygon: boolean;
  arbitrum: boolean;
}

interface DepositAddress {
  network: string;
  address: string;
  qrCode?: string;
}

interface Asset {
  id: string;
  name: string;
  symbol: string;
  realSymbol?: string; // Original symbol before rToken conversion
  type: 'crypto' | 'token' | 'fiat' | 'rtoken';
  price: number;
  contractAddress?: string;
  chainContracts?: Record<string, ChainContract>;
  depositAddresses?: Record<string, DepositAddress>;
  decimals: number;
  status: 'active' | 'inactive' | 'pending' | 'importing';
  logo?: string;
  createdAt: string;
  updatedAt: string;
  syncWithDex: boolean;
  visibilitySettings: {
    wallets: boolean;
    contracts: boolean;
    trading: boolean;
    transactions: boolean;
    swap: boolean;
    buyCrypto: boolean;
    charts: boolean;
  };
  syncStatus?: 'synced' | 'not_synced' | 'syncing' | 'error';
  coinGeckoId?: string;
  livePriceTracking: boolean;
  supportedNetworks?: NetworkSupport;
  tradingPairs?: string[];
  metadata?: {
    description?: string;
    website?: string;
    explorer?: string;
    marketCap?: number;
    volume24h?: number;
    change24h?: number;
    totalSupply?: number;
    circulatingSupply?: number;
  };
  automationSettings?: {
    autoGenerateDeposits: boolean;
    enableTrading: boolean;
    trackLivePrice: boolean;
    showInSwap: boolean;
    showInBuyCrypto: boolean;
    createDefaultPairs: boolean;
  };
}

interface UniversalTokenForm {
  name: string;
  symbol: string;
  price: number;
  coinGeckoId: string;
  supportedNetworks: NetworkSupport;
  chainContracts: Record<string, string>;
  automationSettings: {
    autoGenerateDeposits: boolean;
    enableTrading: boolean;
    trackLivePrice: boolean;
    showInSwap: boolean;
    showInBuyCrypto: boolean;
    createDefaultPairs: boolean;
  };
  visibilitySettings: {
    wallets: boolean;
    contracts: boolean;
    trading: boolean;
    transactions: boolean;
    swap: boolean;
    buyCrypto: boolean;
    charts: boolean;
  };
}

const SUPPORTED_NETWORKS = [
  { key: 'ethereum', name: 'Ethereum', symbol: 'ETH', color: 'blue' },
  { key: 'bsc', name: 'Binance Smart Chain', symbol: 'BNB', color: 'yellow' },
  { key: 'solana', name: 'Solana', symbol: 'SOL', color: 'purple' },
  { key: 'avalanche', name: 'Avalanche', symbol: 'AVAX', color: 'red' },
  { key: 'polygon', name: 'Polygon', symbol: 'MATIC', color: 'indigo' },
  { key: 'arbitrum', name: 'Arbitrum', symbol: 'ARB', color: 'cyan' },
];

const DEFAULT_TRADING_PAIRS = ['rUSDT', 'rETH', 'rBTC'];

export default function AssetsPage() {
  const [assets, setAssets] = useState<Asset[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showModal, setShowModal] = useState(false);
  const [showUniversalModal, setShowUniversalModal] = useState(false);
  const [selectedAsset, setSelectedAsset] = useState<Asset | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState<string>('all');
  const [filterStatus, setFilterStatus] = useState<string>('all');
  const [importing, setImporting] = useState(false);

  // Add missing state variables for Universal Import
  const [selectedNetworks, setSelectedNetworks] = useState<string[]>([]);
  const [networkContracts, setNetworkContracts] = useState<Record<string, string>>({});

  const [universalForm, setUniversalForm] = useState<UniversalTokenForm>({
    name: '',
    symbol: '',
    price: 0,
    coinGeckoId: '',
    supportedNetworks: {
      ethereum: false,
      bsc: false,
      solana: false,
      avalanche: false,
      polygon: false,
      arbitrum: false,
    },
    chainContracts: {},
    automationSettings: {
      autoGenerateDeposits: true,
      enableTrading: true,
      trackLivePrice: true,
      showInSwap: true,
      showInBuyCrypto: true,
      createDefaultPairs: true,
    },
    visibilitySettings: {
      wallets: true,
      contracts: true,
      trading: true,
      transactions: true,
      swap: true,
      buyCrypto: true,
      charts: true,
    },
  });

  useEffect(() => {
    fetchAssets();
  }, []);

  const fetchAssets = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await apiClient.get<{ data: Asset[] }>('/api/admin/assets');
      
      if (response.success && response.data?.data) {
        setAssets(response.data.data);
      } else {
        // Enhanced mock data with rTokens
        const mockAssets: Asset[] = [
          {
            id: '1',
            name: 'RSA Chain',
            symbol: 'RSA',
            type: 'crypto',
            price: 0.85,
            decimals: 18,
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            syncWithDex: true,
            livePriceTracking: true,
            visibilitySettings: {
              wallets: true,
              contracts: true,
              trading: true,
              transactions: true,
              swap: true,
              buyCrypto: true,
              charts: true,
            },
            syncStatus: 'synced',
            coinGeckoId: 'rsa-chain',
            tradingPairs: ['rUSDT', 'rBTC', 'rETH'],
            metadata: {
              description: 'Native token of RSA Chain',
              marketCap: 50000000,
              volume24h: 1250000,
              change24h: 2.5,
            }
          },
          {
            id: '2',
            name: 'Wrapped Shiba Inu',
            symbol: 'rSHIBA',
            realSymbol: 'SHIBA',
            type: 'rtoken',
            price: 0.000012,
            decimals: 18,
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            syncWithDex: true,
            livePriceTracking: true,
            visibilitySettings: {
              wallets: true,
              contracts: true,
              trading: true,
              transactions: true,
              swap: true,
              buyCrypto: true,
              charts: true,
            },
            syncStatus: 'synced',
            coinGeckoId: 'shiba-inu',
            supportedNetworks: {
              ethereum: true,
              bsc: true,
              solana: false,
              avalanche: false,
              polygon: true,
              arbitrum: false,
            },
            chainContracts: {
              ethereum: { contract: '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE', decimals: 18, verified: true },
              bsc: { contract: '0x2859e4544C4bB03966803b044A93563Bd2D0DD4D', decimals: 18, verified: true },
              polygon: { contract: '0x6f8a06447Ff6FcF75d803135a7de15CE88C1d4ec', decimals: 18, verified: true },
            },
            depositAddresses: {
              ethereum: { network: 'ethereum', address: '0xUser1DepositEthereum...' },
              bsc: { network: 'bsc', address: '0xUser1DepositBSC...' },
              polygon: { network: 'polygon', address: '0xUser1DepositPolygon...' },
            },
            tradingPairs: ['rUSDT', 'rETH'],
            automationSettings: {
              autoGenerateDeposits: true,
              enableTrading: true,
              trackLivePrice: true,
              showInSwap: true,
              showInBuyCrypto: true,
              createDefaultPairs: true,
            },
            metadata: {
              description: 'Wrapped Shiba Inu token on RSA Chain',
              website: 'https://shibatoken.com',
              marketCap: 5000000000,
              volume24h: 50000000,
              change24h: -3.2,
              totalSupply: 589735030408323,
              circulatingSupply: 589735030408323,
            }
          }
        ];
        setAssets(mockAssets);
      }
    } catch (error: any) {
      console.error('Assets fetch error:', error);
      setError('Failed to load assets');
      toast.error('Failed to load assets');
    } finally {
      setLoading(false);
    }
  };

  const handleUniversalImport = async () => {
    // Get selected networks from the supportedNetworks object
    const selectedNetworksList = Object.entries(universalForm.supportedNetworks)
      .filter(([_, selected]) => selected)
      .map(([network, _]) => network);
    
    if (!universalForm.name || !universalForm.symbol || selectedNetworksList.length === 0) {
      toast.error('Please fill in all required fields and select at least one network');
      return;
    }

    setImporting(true);
    
    try {
      // Prepare the import data
      const importData = {
        name: universalForm.name,
        symbol: universalForm.symbol,
        price: universalForm.price,
        coinGeckoId: universalForm.coinGeckoId,
        selectedNetworks: selectedNetworksList,
        chainContracts: universalForm.chainContracts,
        automationSettings: universalForm.automationSettings,
        visibilitySettings: universalForm.visibilitySettings
      };

      // Show initial progress
      toast.loading('Starting Universal Token Import...', { id: 'import-progress' });
      
      // Call the backend API
      const response = await apiClient.post<{ rTokenSymbol: string; integrationStatus: any }>('/api/assets/import-token', importData);
      
      if (response.success) {
        // Show success message
        toast.success(
          `Successfully imported ${universalForm.symbol} as ${response.data?.rTokenSymbol || 'r' + universalForm.symbol}!`,
          { id: 'import-progress' }
        );

        // Reset form
        setUniversalForm({
          name: '',
          symbol: '',
          price: 0,
          coinGeckoId: '',
          supportedNetworks: {
            ethereum: false,
            bsc: false,
            solana: false,
            avalanche: false,
            polygon: false,
            arbitrum: false,
          },
          chainContracts: {},
          automationSettings: {
            autoGenerateDeposits: true,
            enableTrading: true,
            trackLivePrice: true,
            showInSwap: true,
            showInBuyCrypto: true,
            createDefaultPairs: true,
          },
          visibilitySettings: {
            wallets: true,
            contracts: true,
            trading: true,
            transactions: true,
            swap: true,
            buyCrypto: true,
            charts: true,
          }
        });
        setSelectedNetworks([]);
        setNetworkContracts({});
        setShowUniversalModal(false);

        // Refresh the assets list to show the new token
        toast.loading('Refreshing assets list...', { id: 'refresh-assets' });
        await fetchAssets();
        toast.success('Assets list updated!', { id: 'refresh-assets' });

        // Show integration status
        const integrationStatus = response.data?.integrationStatus;
        if (integrationStatus) {
          setTimeout(() => {
            toast.success(
              `Integration complete: ${Object.values(integrationStatus).filter(v => v === 'completed').length} steps completed`,
              { duration: 5000 }
            );
          }, 1000);
        }

      } else {
        toast.error(response.error || 'Failed to import token', { id: 'import-progress' });
      }

    } catch (error: any) {
      console.error('Universal import error:', error);
      toast.error(
        error.response?.data?.error || error.message || 'Import failed. Please try again.',
        { id: 'import-progress' }
      );
    } finally {
      setImporting(false);
    }
  };

  const resetUniversalForm = () => {
    setUniversalForm({
      name: '',
      symbol: '',
      price: 0,
      coinGeckoId: '',
      supportedNetworks: {
        ethereum: false,
        bsc: false,
        solana: false,
        avalanche: false,
        polygon: false,
        arbitrum: false,
      },
      chainContracts: {},
      automationSettings: {
        autoGenerateDeposits: true,
        enableTrading: true,
        trackLivePrice: true,
        showInSwap: true,
        showInBuyCrypto: true,
        createDefaultPairs: true,
      },
      visibilitySettings: {
        wallets: true,
        contracts: true,
        trading: true,
        transactions: true,
        swap: true,
        buyCrypto: true,
        charts: true,
      },
    });
  };

  const handleCoinGeckoLookup = async () => {
    if (!universalForm.symbol) {
      toast.error('Please enter a token symbol first');
      return;
    }

    try {
      // Mock CoinGecko lookup - in real implementation, call CoinGecko API
      const mockData = {
        name: universalForm.symbol === 'SHIB' ? 'Shiba Inu' : `${universalForm.symbol} Token`,
        current_price: universalForm.symbol === 'SHIB' ? 0.000012 : 1.0,
        id: universalForm.symbol.toLowerCase(),
      };

      setUniversalForm(prev => ({
        ...prev,
        name: mockData.name,
        price: mockData.current_price,
        coinGeckoId: mockData.id,
      }));

      toast.success('Token data fetched from CoinGecko');
    } catch (error) {
      toast.error('Failed to fetch from CoinGecko');
    }
  };

  const filteredAssets = assets.filter(asset => {
    const matchesSearch = asset.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         asset.symbol.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesType = filterType === 'all' || asset.type === filterType;
    const matchesStatus = filterStatus === 'all' || asset.status === filterStatus;
    return matchesSearch && matchesType && matchesStatus;
  });

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'active': return 'bg-green-100 text-green-800';
      case 'inactive': return 'bg-gray-100 text-gray-800';
      case 'pending': return 'bg-yellow-100 text-yellow-800';
      case 'importing': return 'bg-blue-100 text-blue-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'crypto': return 'bg-blue-100 text-blue-800';
      case 'token': return 'bg-purple-100 text-purple-800';
      case 'rtoken': return 'bg-orange-100 text-orange-800';
      case 'fiat': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getSyncStatusIcon = (status?: string) => {
    switch (status) {
      case 'synced': return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'syncing': return <Clock className="w-4 h-4 text-blue-500 animate-spin" />;
      case 'error': return <AlertCircle className="w-4 h-4 text-red-500" />;
      default: return <AlertCircle className="w-4 h-4 text-gray-500" />;
    }
  };

  return (
    <Layout>
      <div className="p-6">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-3xl font-bold">Universal Asset Management</h1>
            <p className="text-gray-600 mt-2">
              Manage tokens with automated multi-chain integration and DEX synchronization
            </p>
          </div>
          <div className="flex space-x-3">
            <button
              onClick={fetchAssets}
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex items-center"
            >
              <RefreshCw className="w-4 h-4 mr-2" />
              Refresh
            </button>
            <button
              onClick={() => setShowUniversalModal(true)}
              className="px-4 py-2 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-md hover:from-purple-700 hover:to-blue-700 transition-colors flex items-center"
            >
              <Zap className="w-4 h-4 mr-2" />
              Universal Import
            </button>
          </div>
        </div>

        {/* Filters */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">Search</label>
              <div className="relative">
                <Search className="w-4 h-4 absolute left-3 top-3 text-gray-400" />
                <input
                  type="text"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
                  placeholder="Search assets..."
                />
              </div>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">Type</label>
              <select
                value={filterType}
                onChange={(e) => setFilterType(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
              >
                <option value="all">All Types</option>
                <option value="crypto">Crypto</option>
                <option value="token">Token</option>
                <option value="rtoken">rToken</option>
                <option value="fiat">Fiat</option>
              </select>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">Status</label>
              <select
                value={filterStatus}
                onChange={(e) => setFilterStatus(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
              >
                <option value="all">All Status</option>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
                <option value="pending">Pending</option>
                <option value="importing">Importing</option>
              </select>
            </div>
            
            <div className="flex items-end">
              <button
                onClick={() => {
                  setSearchTerm('');
                  setFilterType('all');
                  setFilterStatus('all');
                }}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors flex items-center"
              >
                <RotateCcw className="w-4 h-4 mr-2" />
                Reset
              </button>
            </div>
          </div>
        </div>

        {/* Assets Table */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          {loading ? (
            <div className="text-center py-8">
              <div className="text-gray-500">Loading assets...</div>
            </div>
          ) : error ? (
            <div className="bg-red-50 border border-red-200 rounded-md p-4 m-6">
              <div className="text-red-800">{error}</div>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Asset
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Type
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Price
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Networks
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Sync
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredAssets.map((asset) => (
                    <tr key={asset.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                            {asset.symbol.charAt(0)}
                          </div>
                          <div className="ml-4">
                            <div className="text-sm font-medium text-gray-900">{asset.name}</div>
                            <div className="text-sm text-gray-500">
                              {asset.symbol}
                              {asset.realSymbol && (
                                <span className="ml-1 text-xs bg-orange-100 text-orange-800 px-1 rounded">
                                  from {asset.realSymbol}
                                </span>
                              )}
                            </div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${getTypeColor(asset.type)}`}>
                          {asset.type}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900">
                          ${asset.price.toLocaleString()}
                          {asset.livePriceTracking && (
                            <span className="ml-1 text-green-500">●</span>
                          )}
                        </div>
                        {asset.metadata?.change24h && (
                          <div className={`text-xs ${asset.metadata.change24h >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                            {asset.metadata.change24h >= 0 ? '+' : ''}{asset.metadata.change24h.toFixed(2)}%
                          </div>
                        )}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex flex-wrap gap-1">
                          {asset.supportedNetworks && Object.entries(asset.supportedNetworks)
                            .filter(([_, supported]) => supported)
                            .map(([network, _]) => {
                              const networkInfo = SUPPORTED_NETWORKS.find(n => n.key === network);
                              return (
                                <span
                                  key={network}
                                  className={`inline-flex px-2 py-1 text-xs font-semibold rounded bg-${networkInfo?.color || 'gray'}-100 text-${networkInfo?.color || 'gray'}-800`}
                                >
                                  {networkInfo?.symbol || network.toUpperCase()}
                                </span>
                              );
                            })}
                          {(!asset.supportedNetworks || Object.values(asset.supportedNetworks).every(v => !v)) && (
                            <span className="text-xs text-gray-500">Native</span>
                          )}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${getStatusColor(asset.status)}`}>
                          {asset.status}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          {getSyncStatusIcon(asset.syncStatus)}
                          <span className="ml-1 text-xs text-gray-500">
                            {asset.syncStatus || 'unknown'}
                          </span>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
                        <button
                          onClick={() => {
                            setSelectedAsset(asset);
                            setShowModal(true);
                          }}
                          className="text-blue-600 hover:text-blue-900"
                        >
                          <Edit3 className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => {
                            if (confirm('Are you sure you want to delete this asset?')) {
                              // Handle delete
                              toast.success('Asset deleted successfully');
                              fetchAssets();
                            }
                          }}
                          className="text-red-600 hover:text-red-900"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>

        {/* Universal Token Import Modal */}
        {showUniversalModal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6 border-b border-gray-200">
                <div className="flex justify-between items-center">
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900">
                      🌍 Universal Token Onboarding System
                    </h3>
                    <p className="text-sm text-gray-600 mt-1">
                      Automated end-to-end integration of external tokens into RSA DEX ecosystem
                    </p>
                  </div>
                  <button
                    onClick={() => setShowUniversalModal(false)}
                    className="text-gray-400 hover:text-gray-600"
                  >
                    <X className="w-6 h-6" />
                  </button>
                </div>
              </div>

              <div className="p-6 space-y-6">
                {/* Step 1: Basic Token Info */}
                <div className="border rounded-lg p-4">
                  <h4 className="text-md font-semibold text-gray-900 mb-4 flex items-center">
                    <span className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-2">1</span>
                    Basic Token Information
                  </h4>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Token Symbol *
                      </label>
                      <div className="flex">
                        <input
                          type="text"
                          value={universalForm.symbol}
                          onChange={(e) => setUniversalForm(prev => ({ ...prev, symbol: e.target.value.toUpperCase() }))}
                          className="flex-1 px-3 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
                          placeholder="e.g., SHIB"
                        />
                        <button
                          onClick={handleCoinGeckoLookup}
                          className="px-3 py-2 bg-orange-500 text-white rounded-r-md hover:bg-orange-600 transition-colors"
                          title="Auto-fetch from CoinGecko"
                        >
                          <Globe className="w-4 h-4" />
                        </button>
                      </div>
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Token Name *
                      </label>
                      <input
                        type="text"
                        value={universalForm.name}
                        onChange={(e) => setUniversalForm(prev => ({ ...prev, name: e.target.value }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
                        placeholder="e.g., Shiba Inu"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Current Price (USD)
                      </label>
                      <input
                        type="number"
                        step="0.000001"
                        value={universalForm.price}
                        onChange={(e) => setUniversalForm(prev => ({ ...prev, price: parseFloat(e.target.value) || 0 }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
                        placeholder="0.000012"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        CoinGecko ID
                      </label>
                      <input
                        type="text"
                        value={universalForm.coinGeckoId}
                        onChange={(e) => setUniversalForm(prev => ({ ...prev, coinGeckoId: e.target.value }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900"
                        placeholder="shiba-inu"
                      />
                    </div>
                  </div>
                </div>

                {/* Step 2: Network Support */}
                <div className="border rounded-lg p-4">
                  <h4 className="text-md font-semibold text-gray-900 mb-4 flex items-center">
                    <span className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-2">2</span>
                    Supported Networks & Contract Addresses
                  </h4>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {SUPPORTED_NETWORKS.map((network) => (
                      <div key={network.key} className="border rounded-lg p-3">
                        <div className="flex items-center mb-2">
                          <input
                            type="checkbox"
                            id={network.key}
                            checked={universalForm.supportedNetworks[network.key as keyof NetworkSupport]}
                            onChange={(e) => setUniversalForm(prev => ({
                              ...prev,
                              supportedNetworks: {
                                ...prev.supportedNetworks,
                                [network.key]: e.target.checked
                              }
                            }))}
                            className="mr-2"
                          />
                          <label htmlFor={network.key} className="text-sm font-medium text-gray-900">
                            {network.name} ({network.symbol})
                          </label>
                        </div>
                        
                        {universalForm.supportedNetworks[network.key as keyof NetworkSupport] && (
                          <input
                            type="text"
                            value={universalForm.chainContracts[network.key] || ''}
                            onChange={(e) => setUniversalForm(prev => ({
                              ...prev,
                              chainContracts: {
                                ...prev.chainContracts,
                                [network.key]: e.target.value
                              }
                            }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white text-gray-900 text-xs"
                            placeholder={`Contract address on ${network.name}`}
                          />
                        )}
                      </div>
                    ))}
                  </div>
                </div>

                {/* Step 3: Automation Settings */}
                <div className="border rounded-lg p-4">
                  <h4 className="text-md font-semibold text-gray-900 mb-4 flex items-center">
                    <span className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-2">3</span>
                    Automation Settings
                  </h4>
                  
                  <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                    {Object.entries(universalForm.automationSettings).map(([key, value]) => (
                      <div key={key} className="flex items-center">
                        <input
                          type="checkbox"
                          id={key}
                          checked={value}
                          onChange={(e) => setUniversalForm(prev => ({
                            ...prev,
                            automationSettings: {
                              ...prev.automationSettings,
                              [key]: e.target.checked
                            }
                          }))}
                          className="mr-2"
                        />
                        <label htmlFor={key} className="text-sm text-gray-900">
                          {key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                        </label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Step 4: Visibility Settings */}
                <div className="border rounded-lg p-4">
                  <h4 className="text-md font-semibold text-gray-900 mb-4 flex items-center">
                    <span className="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-2">4</span>
                    Visibility in RSA DEX Features
                  </h4>
                  
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    {Object.entries(universalForm.visibilitySettings).map(([key, value]) => (
                      <div key={key} className="flex items-center">
                        <input
                          type="checkbox"
                          id={`visibility-${key}`}
                          checked={value}
                          onChange={(e) => setUniversalForm(prev => ({
                            ...prev,
                            visibilitySettings: {
                              ...prev.visibilitySettings,
                              [key]: e.target.checked
                            }
                          }))}
                          className="mr-2"
                        />
                        <label htmlFor={`visibility-${key}`} className="text-sm text-gray-900 capitalize">
                          {key}
                        </label>
                      </div>
                    ))}
                  </div>
                </div>

                {/* Integration Preview */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <h4 className="text-md font-semibold text-blue-900 mb-2">
                    🚀 What will happen when you import:
                  </h4>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li>✅ Create rToken contract on RSA Chain (r{universalForm.symbol})</li>
                    <li>✅ Generate deposit addresses for selected networks</li>
                    <li>✅ Set up trading pairs with rUSDT, rETH, rBTC</li>
                    <li>✅ Enable live price tracking from CoinGecko</li>
                    <li>✅ Add to Swap, Exchange, Buy Crypto, and Charts</li>
                    <li>✅ Update all DEX modules automatically</li>
                  </ul>
                </div>
              </div>

              <div className="px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
                <button
                  onClick={() => setShowUniversalModal(false)}
                  className="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleUniversalImport}
                  disabled={importing || !universalForm.name || !universalForm.symbol}
                  className="px-6 py-2 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-md hover:from-purple-700 hover:to-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
                >
                  {importing ? (
                    <>
                      <Clock className="w-4 h-4 mr-2 animate-spin" />
                      Importing...
                    </>
                  ) : (
                    <>
                      <Zap className="w-4 h-4 mr-2" />
                      Import Token
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </Layout>
  );
}